{"remainingRequest":"C:\\work\\chat-client\\node_modules\\babel-loader\\lib\\index.js!C:\\work\\chat-client\\src\\store\\socket.js","dependencies":[{"path":"C:\\work\\chat-client\\src\\store\\socket.js","mtime":1557775813832},{"path":"C:\\work\\chat-client\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\work\\chat-client\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import _Promise from \"C:\\\\work\\\\chat-client\\\\node_modules\\\\@babel\\\\runtime-corejs2/core-js/promise\";\nimport _defineProperty from \"C:\\\\work\\\\chat-client\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/defineProperty\";\nimport _objectSpread from \"C:\\\\work\\\\chat-client\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/objectSpread\";\nimport \"regenerator-runtime/runtime\";\nimport _asyncToGenerator from \"C:\\\\work\\\\chat-client\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/asyncToGenerator\";\n\n/**\n * @class SocketStore\n */\nimport io from 'socket.io-client';\nimport config from '../config';\nimport { eventBus } from './../event-bus';\n\nvar chennelExists =\n/*#__PURE__*/\nfunction () {\n  var _ref = _asyncToGenerator(\n  /*#__PURE__*/\n  regeneratorRuntime.mark(function _callee() {\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function chennelExists() {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexport default {\n  namespaced: true,\n  state: {\n    connected: false,\n    profile: null,\n    socket: null,\n    channels: {}\n  },\n  mutations: {\n    connect: function connect(state, _ref2) {\n      var socket = _ref2.socket;\n      state.socket = socket;\n      state.connected = true;\n    },\n    updateProfile: function updateProfile(state, profile) {\n      state.profile = profile;\n    },\n    updateConnectionStatus: function updateConnectionStatus(state, connected) {\n      state.connected = connected;\n    },\n    updateChannelMeta: function updateChannelMeta(state, newChannelData) {\n      state.channels = _objectSpread({}, state.channels, _defineProperty({}, newChannelData.id, newChannelData));\n      eventBus.emit(\"channel-\".concat(newChannelData.id, \"-update\"), newChannelData);\n    }\n  },\n  actions: {\n    connect: function connect(_ref3, accessToken) {\n      var commit = _ref3.commit;\n      var connectionOptions = {\n        transports: ['websocket'],\n        query: {\n          token: accessToken,\n          client_id: config.client.id\n        }\n      };\n      var socket = io.connect(config.socket.serverUrl, connectionOptions);\n      socket.on('connect_error', function (err) {\n        console.error('Socket connect error', err);\n        commit('updateConnectionStatus', false);\n      });\n      socket.on('reconnect', function () {\n        console.debug('Reconnected...');\n        commit('updateConnectionStatus', true);\n      });\n      socket.once('error', function (err) {\n        console.error('Socket error', err);\n      });\n      socket.once('connect', function () {\n        commit('connect', {\n          socket: socket\n        });\n      });\n      console.log('emitting profile req.');\n      socket.emit('user-profile', {}, function (data) {\n        if (data.error) {\n          console.error('Unable to get user profile', data.error);\n        }\n\n        console.log('We have a profile: ', data);\n        commit('updateProfile', data.profile);\n      }); //standard evt. handlers\n\n      socket.on('user-profile-changed', function (newProfile) {\n        console.log('My profile change requested!', newProfile);\n        commit('updateProfile', newProfile);\n      });\n      socket.on('channel-data-changed', function (newChannelData) {\n        console.log('channel-data-changed: ', newChannelData);\n        commit('updateChannelMeta', newChannelData);\n      });\n    },\n    connectToChannel: function connectToChannel(_ref4, channelId) {\n      var state = _ref4.state;\n      state.socket.emit('channel-join', {\n        channelId: channelId\n      }, function (response) {\n        if (response.error) {\n          console.error(\"Unable to join channel \".concat(channelId), response);\n        }\n\n        console.log(\"Connected to channel \".concat(channelId), response);\n      });\n    },\n\n    /**\n     * @memberOf SocketStore\n     * @param state\n     */\n    getChannelInfo: function getChannelInfo(_ref5, channelId) {\n      var state = _ref5.state,\n          commit = _ref5.commit;\n\n      if (state.channels[channelId]) {\n        return state.channels[channelId];\n      }\n\n      return new _Promise(function (resolve, reject) {\n        state.socket.emit('channel-get-meta', {\n          channelId: channelId\n        }, function (response) {\n          console.log('got ch. meta', response);\n\n          if (response.error) {\n            console.error(\"Unable to join channel \".concat(channelId), response);\n            return reject(new Error('Unable to get channel info'));\n          }\n\n          commit('updateChannelMeta', response.channel);\n          return resolve(response.channel);\n        });\n      });\n    },\n\n    /**\n     * @memberOf SocketStore\n     * @param invitationId\n     */\n    rejectInvitation: function rejectInvitation(_ref6, invitationId) {\n      var state = _ref6.state,\n          commit = _ref6.commit;\n      return new _Promise(function (resolve, reject) {\n        state.socket.emit('invitation-reject', {\n          invitationId: invitationId\n        }, function (response) {\n          if (response.error) {\n            console.error(\"Unable to reject invitation\", response);\n            return reject(new Error('Unable to reject invitation'));\n          }\n\n          return resolve(response);\n        });\n      });\n    },\n\n    /**\n     * @memberOf SocketStore\n     * @param invitationId\n     */\n    acceptInvitation: function acceptInvitation(_ref7, invitationId) {\n      var state = _ref7.state,\n          commit = _ref7.commit;\n      return new _Promise(function (resolve, reject) {\n        state.socket.emit('invitation-accept', {\n          invitationId: invitationId\n        }, function (response) {\n          if (response.error) {\n            console.error(\"Unable to accept invitation\", response);\n            return reject(new Error('Unable to accept invitation'));\n          }\n\n          return resolve(response);\n        });\n      });\n    },\n\n    /**\n     * @memberOf SocketStore\n     */\n    inviteUserToChannel: function inviteUserToChannel(_ref8, _ref9) {\n      var state = _ref8.state,\n          commit = _ref8.commit;\n      var userId = _ref9.userId,\n          channelId = _ref9.channelId,\n          text = _ref9.text;\n      return new _Promise(function (resolve, reject) {\n        state.socket.emit('invitation-create', {\n          channelId: channelId,\n          userId: userId,\n          text: text\n        }, function (response) {\n          if (response.error) {\n            console.error(\"Unable to invite user to channel \".concat(channelId), response);\n            return reject(new Error('Unable to invite user to channel'));\n          }\n\n          return resolve(response.channel);\n        });\n      });\n    },\n    conversationExists: function conversationExists(_ref10, userId) {\n      var state = _ref10.state;\n      return new _Promise(function (resolve, reject) {\n        state.socket.emit('channel-with-user-exists', {\n          targetUserId: userId\n        }, function (response) {\n          if (response.error) {\n            console.error(\"Unable to check conversation exists with user \".concat(userId), response);\n            return reject(new Error(\"Unable to create a conversation\"));\n          }\n\n          console.log(\"Channel with user \".concat(userId, \" exists: \").concat(response.exists), response);\n          return resolve(response);\n        });\n      });\n    },\n    createAndConnectToConversation: function createAndConnectToConversation(_ref11, userId) {\n      var state = _ref11.state,\n          commit = _ref11.commit;\n      return new _Promise(function (resolve, reject) {\n        state.socket.emit('channel-create', {\n          targetUserId: userId\n        }, function (response) {\n          if (response.error) {\n            console.error(\"Unable to create a conversation\", response);\n            return reject(new Error(\"Unable to create a conversation\"));\n          }\n\n          console.log(\"Channel \".concat(response.channel.id, \" created\"), response);\n          commit('updateChannelMeta', response.channel);\n          return resolve(response.channel);\n        });\n      });\n    },\n\n    /**\n     * @memberOf SocketStore\n     * @param state\n     * @param name\n     */\n    createAndConnectToChannel: function createAndConnectToChannel(_ref12, name) {\n      var state = _ref12.state,\n          commit = _ref12.commit;\n      state.socket.emit('channel-create', {\n        meta: {\n          name: name\n        }\n      }, function (response) {\n        if (response.error) {\n          console.error(\"Unable to create a channel\", response);\n        }\n\n        console.log(\"Channel \".concat(response.channel.id, \" created\"), response);\n        commit('updateChannelMeta', response.channel);\n      });\n    },\n    leaveChannel: function leaveChannel(_ref13, channelId) {\n      var state = _ref13.state;\n      state.socket.emit('channel-leave', {\n        channelId: channelId\n      }, function (response) {\n        if (response.error) {\n          console.error(\"Unable to leave channel \".concat(channelId), response);\n        }\n\n        console.log(\"Channel \".concat(channelId, \" left\"), response);\n      });\n    },\n    getPublicChannelsList: function getPublicChannelsList(_ref14) {\n      var state = _ref14.state;\n      var page = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var rowsPerPage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n      return new _Promise(function (resolve, reject) {\n        state.socket.emit('channels-list-public', {\n          page: page,\n          rowsPerPage: rowsPerPage\n        }, function (response) {\n          if (response.error) {\n            reject(new Error('Unable to get public channels list'));\n          }\n\n          return resolve(response);\n        });\n      });\n    },\n    sendMessage: function sendMessage(_ref15, event) {\n      var state = _ref15.state;\n      console.log('Sending', event);\n      return new _Promise(function (resolve, reject) {\n        state.socket.emit('message', event, function (response) {\n          if (response.error) {\n            console.error(response);\n            reject(new Error('Unable send message'));\n          }\n\n          return resolve(response.message);\n        });\n      });\n    }\n  },\n  getters: {\n    socket: function socket(state) {\n      return state.socket;\n    },\n    connected: function connected(state) {\n      return state.connected;\n    },\n    profile: function profile(state) {\n      return state.profile;\n    },\n    channels: function channels(state) {\n      return state.channels;\n    }\n  }\n};",{"version":3,"sources":["C:\\work\\chat-client\\src\\store\\socket.js"],"names":["io","config","eventBus","chennelExists","namespaced","state","connected","profile","socket","channels","mutations","connect","updateProfile","updateConnectionStatus","updateChannelMeta","newChannelData","id","emit","actions","accessToken","commit","connectionOptions","transports","query","token","client_id","client","serverUrl","on","err","console","error","debug","once","log","data","newProfile","connectToChannel","channelId","response","getChannelInfo","resolve","reject","Error","channel","rejectInvitation","invitationId","acceptInvitation","inviteUserToChannel","userId","text","conversationExists","targetUserId","exists","createAndConnectToConversation","createAndConnectToChannel","name","meta","leaveChannel","getPublicChannelsList","page","rowsPerPage","sendMessage","event","message","getters"],"mappings":"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","sourcesContent":["/**\n * @class SocketStore\n */\nimport io from 'socket.io-client';\nimport config from '../config';\nimport { eventBus } from './../event-bus';\n\nconst chennelExists = async () => {\n\n};\n\nexport default {\n  namespaced: true,\n  state: {\n    connected: false,\n    profile: null,\n    socket: null,\n    channels: {}\n  },\n  mutations: {\n    connect(state, { socket }) {\n      state.socket = socket;\n      state.connected = true;\n    },\n    updateProfile(state, profile) {\n      state.profile = profile;\n    },\n    updateConnectionStatus(state, connected) {\n      state.connected = connected;\n    },\n    updateChannelMeta(state, newChannelData) {\n      state.channels = {\n        ...state.channels,\n        [newChannelData.id]: newChannelData,\n      };\n      eventBus.emit(`channel-${newChannelData.id}-update`, newChannelData);\n    }\n  },\n  actions: {\n    connect({ commit }, accessToken) {\n      const connectionOptions = {\n        transports: ['websocket'],\n        query: {\n          token: accessToken,\n          client_id: config.client.id,\n        },\n      };\n      const socket = io.connect(config.socket.serverUrl, connectionOptions);\n      socket.on('connect_error', (err) => {\n        console.error('Socket connect error', err);\n        commit('updateConnectionStatus', false);\n      });\n      socket.on('reconnect', () => {\n        console.debug('Reconnected...');\n        commit('updateConnectionStatus', true);\n      });\n      socket.once('error', (err) => {\n        console.error('Socket error', err);\n      });\n      socket.once('connect', () => {\n        commit('connect', { socket });\n      });\n      console.log('emitting profile req.');\n      socket.emit('user-profile', {}, (data) => {\n        if (data.error) {\n          console.error('Unable to get user profile', data.error);\n        }\n        console.log('We have a profile: ', data);\n        commit('updateProfile', data.profile);\n      });\n      //standard evt. handlers\n      socket.on('user-profile-changed', (newProfile) => {\n        console.log('My profile change requested!', newProfile);\n        commit('updateProfile', newProfile);\n      });\n      socket.on('channel-data-changed', (newChannelData) => {\n        console.log('channel-data-changed: ', newChannelData);\n        commit('updateChannelMeta', newChannelData);\n      });\n    },\n    connectToChannel({ state }, channelId) {\n      state.socket.emit('channel-join', { channelId }, (response) => {\n        if (response.error) {\n          console.error(`Unable to join channel ${channelId}`, response);\n        }\n        console.log(`Connected to channel ${channelId}`, response);\n      });\n    },\n    /**\n     * @memberOf SocketStore\n     * @param state\n     */\n    getChannelInfo({ state, commit }, channelId) {\n      if (state.channels[channelId]) {\n        return state.channels[channelId];\n      }\n      return new Promise((resolve, reject) => {\n        state.socket.emit('channel-get-meta', { channelId }, (response) => {\n          console.log('got ch. meta', response);\n          if (response.error) {\n            console.error(`Unable to join channel ${channelId}`, response);\n            return reject(new Error('Unable to get channel info'));\n          }\n          commit('updateChannelMeta', response.channel);\n          return resolve(response.channel);\n        });\n      });\n    },\n    /**\n     * @memberOf SocketStore\n     * @param invitationId\n     */\n    rejectInvitation({ state, commit }, invitationId) {\n      return new Promise((resolve, reject) => {\n        state.socket.emit('invitation-reject', { invitationId }, (response) => {\n          if (response.error) {\n            console.error(`Unable to reject invitation`, response);\n            return reject(new Error('Unable to reject invitation'));\n          }\n          return resolve(response);\n        });\n      });\n    },\n    /**\n     * @memberOf SocketStore\n     * @param invitationId\n     */\n    acceptInvitation({ state, commit }, invitationId) {\n      return new Promise((resolve, reject) => {\n        state.socket.emit('invitation-accept', { invitationId }, (response) => {\n          if (response.error) {\n            console.error(`Unable to accept invitation`, response);\n            return reject(new Error('Unable to accept invitation'));\n          }\n          return resolve(response);\n        });\n      });\n    },\n    /**\n     * @memberOf SocketStore\n     */\n    inviteUserToChannel({ state, commit }, { userId, channelId, text }) {\n      return new Promise((resolve, reject) => {\n        state.socket.emit('invitation-create', {\n          channelId,\n          userId,\n          text\n        }, (response) => {\n          if (response.error) {\n            console.error(`Unable to invite user to channel ${channelId}`, response);\n            return reject(new Error('Unable to invite user to channel'));\n          }\n          return resolve(response.channel);\n        });\n      });\n    },\n    conversationExists({ state }, userId) {\n      return new Promise((resolve, reject) => {\n        state.socket.emit('channel-with-user-exists', { targetUserId: userId }, (response) => {\n          if (response.error) {\n            console.error(`Unable to check conversation exists with user ${userId}`, response);\n            return reject(new Error(`Unable to create a conversation`));\n          }\n\n          console.log(`Channel with user ${userId} exists: ${response.exists}`, response);\n          return resolve(response);\n        });\n      });\n    },\n    createAndConnectToConversation({ state, commit }, userId) {\n      return new Promise((resolve, reject) => {\n        state.socket.emit('channel-create', { targetUserId: userId }, (response) => {\n          if (response.error) {\n            console.error(`Unable to create a conversation`, response);\n            return reject(new Error(`Unable to create a conversation`));\n          }\n\n          console.log(`Channel ${response.channel.id} created`, response);\n          commit('updateChannelMeta', response.channel);\n          return resolve(response.channel);\n        });\n      });\n    },\n    /**\n     * @memberOf SocketStore\n     * @param state\n     * @param name\n     */\n    createAndConnectToChannel({ state, commit }, name) {\n      state.socket.emit('channel-create', { meta: { name } }, (response) => {\n        if (response.error) {\n          console.error(`Unable to create a channel`, response);\n        }\n\n        console.log(`Channel ${response.channel.id} created`, response);\n        commit('updateChannelMeta', response.channel);\n      });\n    },\n    leaveChannel({ state }, channelId) {\n      state.socket.emit('channel-leave', { channelId }, (response) => {\n        if (response.error) {\n          console.error(`Unable to leave channel ${channelId}`, response);\n        }\n        console.log(`Channel ${channelId} left`, response);\n      });\n    },\n    getPublicChannelsList({ state }, page = 1, rowsPerPage = 10) {\n      return new Promise((resolve, reject) => {\n        state.socket.emit('channels-list-public', {\n          page,\n          rowsPerPage\n        }, (response) => {\n          if (response.error) {\n            reject(new Error('Unable to get public channels list'));\n          }\n          return resolve(response);\n        });\n      });\n    },\n    sendMessage({ state }, event) {\n      console.log('Sending', event);\n      return new Promise((resolve, reject) => {\n        state.socket.emit('message', event, (response) => {\n          if (response.error) {\n            console.error(response);\n            reject(new Error('Unable send message'));\n          }\n          return resolve(response.message);\n        });\n      });\n    }\n  },\n  getters: {\n    socket(state) {\n      return state.socket;\n    },\n    connected(state) {\n      return state.connected;\n    },\n    profile(state) {\n      return state.profile;\n    },\n    channels(state) {\n      return state.channels;\n    }\n  },\n};\n"]}]}