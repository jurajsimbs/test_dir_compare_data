{"remainingRequest":"C:\\work\\chat-client\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!C:\\work\\chat-client\\src\\views\\channel.vue?vue&type=script&lang=js&","dependencies":[{"path":"C:\\work\\chat-client\\src\\views\\channel.vue","mtime":1557593021355},{"path":"C:\\work\\chat-client\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\work\\chat-client\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"C:\\work\\chat-client\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\work\\chat-client\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport {mapActions, mapGetters} from 'vuex';\nimport DateWidget from './../component/date-widget';\nimport InviteUserDialog from './../component/dialog/invite-user';\nimport {eventBus} from './../event-bus';\nimport {channel as Channel} from '@bistudio/chat-constants'\n\nexport default {\n    components: {\n        DateWidget,\n        InviteUserDialog\n    },\n    data() {\n        return {\n            message                : null,\n            messagesBuffer         : [],\n            listening              : false,\n            channelInfo            : null,\n            membersVisible         : true,\n            userInviteDialogVisible: false,\n            members: [],\n        };\n    },\n    methods   : {\n        ...mapActions({\n            leaveChannel       : 'Socket/leaveChannel',\n            sendMessage        : 'Socket/sendMessage',\n            getChannelInfo     : 'Socket/getChannelInfo', /** @see SocketStore.getChannelInfo */\n            inviteUserToChannel: 'Socket/inviteUserToChannel', /** @see SocketStore.inviteUserToChannel */\n            getUserName        : 'User/getInfo'\n        }),\n        async resolveUserName(userId) {\n            let data = await this.getUserName(userId);\n            return data.username;\n        },\n        inviteUser({userId, text}) {\n            this.hideInviteUserDialog();\n            this.inviteUserToChannel({userId, channelId: this.channelId, text});\n        },\n        showInviteUserDialog() {\n            this.userInviteDialogVisible = true\n        },\n        hideInviteUserDialog() {\n            this.userInviteDialogVisible = false\n        },\n        async leave() {\n            let res;\n            if (this.channelInfo.type === 'private_group' && this.profile.ownerOf.includes(this.channelId)) {\n                res = await this.$confirm('Do you really want to cancel this private group owned by you? Whole conversation will be destroyed and all members will be forced to leave.');\n            } else if (this.channelInfo.type === 'private_group') {\n                res = await this.$confirm('Do you really want to leave this provate group?');\n            } else if (this.channelInfo.type === 'public_group') {\n                res = await this.$confirm('Do you really want to leave this channel?');\n            } else {\n                res = await this.$confirm('Do you really want to leave this conversation?');\n            }\n            if (!res) {\n                return;\n            }\n            await this.leaveChannel(this.channelId);\n            this.$router.push({name: 'home'});\n        },\n        async onTextAreaKeypress(evt) {\n            if (evt.shiftKey) {\n                return;\n            }\n            this.tryToSendMessage();\n            evt.preventDefault();\n            evt.stopPropagation();\n        },\n        async tryToSendMessage() {\n            let message = await this.sendMessage({text: this.message, targetChannelId: this.channelId});\n            this.messagesBuffer.push(message);\n            this.message = null;\n        },\n        clearMessage() {\n            this.message = null;\n        },\n        onMessageReceived(message) {\n            if (message.targetChannelId === this.channelId) {\n                this.messagesBuffer.push(message);\n                if (this.messagesBuffer.length > 200) {\n                    this.messagesBuffer.shift();\n                }\n            }\n            setTimeout(() => {\n                var container = this.$el.querySelector(\"#messages-list\");\n                container.scrollTop = container.scrollHeight;\n            }, 10);\n        },\n        async refreshChannelInfo(channelId) {\n            this.channelInfo = await this.getChannelInfo(channelId);\n            if (!this.channelInfo || !this.channelInfo.members) {\n                return;\n            }\n            let members = [];\n            let userIds = Object.keys(this.channelInfo.members);\n            for (let i = 0; i < userIds.length; i++) {\n                let userData = await this.getUserName({accessToken: this.accessToken, userId: this.channelInfo.members[userIds[i]].userId});\n                members.push({userId: userData.id, username: userData.username});\n            }\n            this.members = members;\n        },\n        onChannelUpdateRequested(newChannelData) {\n            this.refreshChannelInfo(newChannelData.id);\n        },\n        async listen() {\n            if (!this.socket || !this.connected) {\n                setTimeout(() => {\n                    this.listen()\n                }, 1000);\n                return;\n            }\n            this.socket.on('message', this.onMessageReceived);\n            eventBus.on(`channel-${this.channelId}-update`, this.onChannelUpdateRequested);\n            this.listening = true;\n            this.refreshChannelInfo(this.channelId);\n        }\n    },\n    async beforeRouteUpdate(to, from, next) {\n        this.messagesBuffer = [];\n        this.members = [];\n        this.refreshChannelInfo(to.params.channelId);\n        next();\n    },\n    computed  : {\n        Channel() {\n            return Channel;\n        },\n        channelId() {\n            return this.$route.params.channelId;\n        },\n        ...mapGetters({\n            socket   : 'Socket/socket',\n            connected: 'Socket/connected',\n            profile  : 'Socket/profile',\n            accessToken: 'Auth/accessToken',\n        }),\n        // members() {\n        //     if (this.channelInfo && this.channelInfo.members) {\n        //         let output = [];\n        //         for (let i = 0; i < this.channelInfo.members.length; i++) {\n        //             let userData = this.getUserName(this.channelInfo.members[i].userId)\n        //         }\n        //         return output;\n        //     }\n        //     return [];\n        // }\n    },\n    // watch: {\n    //     async channelInfo(newInfo) {\n    //         let members = [];\n    //         for (let i = 0; i < newInfo.length; i++) {\n    //             let userData = await this.getUserName(newInfo[i].userId);\n    //             members.push(userData.username);\n    //         }\n    //         this.members = members;\n    //     }\n    // },\n    mounted() {\n        this.messagesBuffer = [];\n        this.listen();\n    },\n    beforeDestroy() {\n        this.socket.off('message', this.onMessageReceived);\n        this.listening = false;\n        eventBus.off(`channel-${this.channelId}-update`, this.onChannelUpdateRequested);\n    },\n};\n",{"version":3,"sources":["channel.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+EA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"channel.vue","sourceRoot":"src/views","sourcesContent":["<template>\r\n    <v-layout column class=\"screen\">\r\n        <v-flex>\r\n            <v-toolbar dense flat relative>\r\n                <v-chip label color=\"red\" v-if=\"profile && profile.ownerOf && profile.ownerOf.includes(channelId)\">\r\n                    <v-icon left>face</v-icon>\r\n                    owner\r\n                </v-chip>\r\n                <v-chip label color=\"light-blue\" v-if=\"channelInfo && channelInfo.type===Channel.TYPE_PUBLIC_GROUP_CHANNEL\">\r\n                    <v-icon left>public</v-icon>\r\n                    public\r\n                </v-chip>\r\n                <v-chip label color=\"light-blue\" v-if=\"channelInfo && channelInfo.type===Channel.TYPE_PRIVATE_GROUP_CHANNEL\">\r\n                    <v-icon left>group_work</v-icon>\r\n                    private\r\n                </v-chip>\r\n                <span>Channel {{channelInfo?channelInfo.meta.name:channelId}}</span>\r\n                <v-spacer></v-spacer>\r\n                <v-btn icon>\r\n                    <v-icon>group</v-icon>\r\n                </v-btn>\r\n                <v-btn icon @click=\"leave\">\r\n                    <v-icon>exit_to_app</v-icon>\r\n                </v-btn>\r\n            </v-toolbar>\r\n        </v-flex>\r\n        <v-flex fill-height>\r\n            <v-layout row fill-height class=\"main-content\">\r\n                <v-flex fill-height class=\"messages-list\" id=\"messages-list\">\r\n                    <v-layout column :key=\"message.id\" v-for=\"message in messagesBuffer\">\r\n                        <div :class=\"(message.fromUserId===profile.id?'own-message':'') + ' ' + (!message.fromUserId?'system-message':'')\">\r\n                            <date-widget v-model=\"message.createdAt\"></date-widget>\r\n                            <b>{{message.fromUserId===profile.id?'You':message.fromUserId}}</b> {{message.text}}\r\n                        </div>\r\n                    </v-layout>\r\n                </v-flex>\r\n\r\n                <v-navigation-drawer\r\n                        v-model=\"membersVisible\"\r\n                        right\r\n                >\r\n                    <v-list dense>\r\n                        <v-list-tile>\r\n                            <v-list-tile-action>\r\n                                <v-btn @click=\"showInviteUserDialog\" icon>\r\n                                    <v-icon>person_add</v-icon>\r\n                                </v-btn>\r\n                            </v-list-tile-action>\r\n                        </v-list-tile>\r\n                        <v-divider></v-divider>\r\n                        <v-list-tile :key=\"idx\" v-for=\"(member, idx) in members\">\r\n                            <v-list-tile-content>\r\n                                <v-list-tile-title>{{member.username || member.userId}} {{member.userId === profile.id?'(you)':''}}\r\n                                </v-list-tile-title>\r\n                            </v-list-tile-content>\r\n                        </v-list-tile>\r\n                    </v-list>\r\n                </v-navigation-drawer>\r\n            </v-layout>\r\n        </v-flex>\r\n        <v-flex>\r\n            <v-layout row>\r\n                <v-flex grow>\r\n                    <v-textarea v-model=\"message\" clearable box light rows=\"3\" class=\"message-textarea\"\r\n                                @keypress.esc=\"clearMessage\"\r\n                                @keypress.enter=\"onTextAreaKeypress\"></v-textarea>\r\n                </v-flex>\r\n                <v-flex shrink>\r\n                    <v-btn icon @click=\"tryToSendMessage\">\r\n                        <v-icon>done</v-icon>\r\n                    </v-btn>\r\n                </v-flex>\r\n            </v-layout>\r\n        </v-flex>\r\n        <invite-user-dialog :visible=\"userInviteDialogVisible\" @invite=\"inviteUser\"\r\n                            @cancel=\"hideInviteUserDialog\"></invite-user-dialog>\r\n    </v-layout>\r\n</template>\r\n<script>\r\n    import {mapActions, mapGetters} from 'vuex';\r\n    import DateWidget from './../component/date-widget';\r\n    import InviteUserDialog from './../component/dialog/invite-user';\r\n    import {eventBus} from './../event-bus';\r\n    import {channel as Channel} from '@bistudio/chat-constants'\r\n\r\n    export default {\r\n        components: {\r\n            DateWidget,\r\n            InviteUserDialog\r\n        },\r\n        data() {\r\n            return {\r\n                message                : null,\r\n                messagesBuffer         : [],\r\n                listening              : false,\r\n                channelInfo            : null,\r\n                membersVisible         : true,\r\n                userInviteDialogVisible: false,\r\n                members: [],\r\n            };\r\n        },\r\n        methods   : {\r\n            ...mapActions({\r\n                leaveChannel       : 'Socket/leaveChannel',\r\n                sendMessage        : 'Socket/sendMessage',\r\n                getChannelInfo     : 'Socket/getChannelInfo', /** @see SocketStore.getChannelInfo */\r\n                inviteUserToChannel: 'Socket/inviteUserToChannel', /** @see SocketStore.inviteUserToChannel */\r\n                getUserName        : 'User/getInfo'\r\n            }),\r\n            async resolveUserName(userId) {\r\n                let data = await this.getUserName(userId);\r\n                return data.username;\r\n            },\r\n            inviteUser({userId, text}) {\r\n                this.hideInviteUserDialog();\r\n                this.inviteUserToChannel({userId, channelId: this.channelId, text});\r\n            },\r\n            showInviteUserDialog() {\r\n                this.userInviteDialogVisible = true\r\n            },\r\n            hideInviteUserDialog() {\r\n                this.userInviteDialogVisible = false\r\n            },\r\n            async leave() {\r\n                let res;\r\n                if (this.channelInfo.type === 'private_group' && this.profile.ownerOf.includes(this.channelId)) {\r\n                    res = await this.$confirm('Do you really want to cancel this private group owned by you? Whole conversation will be destroyed and all members will be forced to leave.');\r\n                } else if (this.channelInfo.type === 'private_group') {\r\n                    res = await this.$confirm('Do you really want to leave this provate group?');\r\n                } else if (this.channelInfo.type === 'public_group') {\r\n                    res = await this.$confirm('Do you really want to leave this channel?');\r\n                } else {\r\n                    res = await this.$confirm('Do you really want to leave this conversation?');\r\n                }\r\n                if (!res) {\r\n                    return;\r\n                }\r\n                await this.leaveChannel(this.channelId);\r\n                this.$router.push({name: 'home'});\r\n            },\r\n            async onTextAreaKeypress(evt) {\r\n                if (evt.shiftKey) {\r\n                    return;\r\n                }\r\n                this.tryToSendMessage();\r\n                evt.preventDefault();\r\n                evt.stopPropagation();\r\n            },\r\n            async tryToSendMessage() {\r\n                let message = await this.sendMessage({text: this.message, targetChannelId: this.channelId});\r\n                this.messagesBuffer.push(message);\r\n                this.message = null;\r\n            },\r\n            clearMessage() {\r\n                this.message = null;\r\n            },\r\n            onMessageReceived(message) {\r\n                if (message.targetChannelId === this.channelId) {\r\n                    this.messagesBuffer.push(message);\r\n                    if (this.messagesBuffer.length > 200) {\r\n                        this.messagesBuffer.shift();\r\n                    }\r\n                }\r\n                setTimeout(() => {\r\n                    var container = this.$el.querySelector(\"#messages-list\");\r\n                    container.scrollTop = container.scrollHeight;\r\n                }, 10);\r\n            },\r\n            async refreshChannelInfo(channelId) {\r\n                this.channelInfo = await this.getChannelInfo(channelId);\r\n                if (!this.channelInfo || !this.channelInfo.members) {\r\n                    return;\r\n                }\r\n                let members = [];\r\n                let userIds = Object.keys(this.channelInfo.members);\r\n                for (let i = 0; i < userIds.length; i++) {\r\n                    let userData = await this.getUserName({accessToken: this.accessToken, userId: this.channelInfo.members[userIds[i]].userId});\r\n                    members.push({userId: userData.id, username: userData.username});\r\n                }\r\n                this.members = members;\r\n            },\r\n            onChannelUpdateRequested(newChannelData) {\r\n                this.refreshChannelInfo(newChannelData.id);\r\n            },\r\n            async listen() {\r\n                if (!this.socket || !this.connected) {\r\n                    setTimeout(() => {\r\n                        this.listen()\r\n                    }, 1000);\r\n                    return;\r\n                }\r\n                this.socket.on('message', this.onMessageReceived);\r\n                eventBus.on(`channel-${this.channelId}-update`, this.onChannelUpdateRequested);\r\n                this.listening = true;\r\n                this.refreshChannelInfo(this.channelId);\r\n            }\r\n        },\r\n        async beforeRouteUpdate(to, from, next) {\r\n            this.messagesBuffer = [];\r\n            this.members = [];\r\n            this.refreshChannelInfo(to.params.channelId);\r\n            next();\r\n        },\r\n        computed  : {\r\n            Channel() {\r\n                return Channel;\r\n            },\r\n            channelId() {\r\n                return this.$route.params.channelId;\r\n            },\r\n            ...mapGetters({\r\n                socket   : 'Socket/socket',\r\n                connected: 'Socket/connected',\r\n                profile  : 'Socket/profile',\r\n                accessToken: 'Auth/accessToken',\r\n            }),\r\n            // members() {\r\n            //     if (this.channelInfo && this.channelInfo.members) {\r\n            //         let output = [];\r\n            //         for (let i = 0; i < this.channelInfo.members.length; i++) {\r\n            //             let userData = this.getUserName(this.channelInfo.members[i].userId)\r\n            //         }\r\n            //         return output;\r\n            //     }\r\n            //     return [];\r\n            // }\r\n        },\r\n        // watch: {\r\n        //     async channelInfo(newInfo) {\r\n        //         let members = [];\r\n        //         for (let i = 0; i < newInfo.length; i++) {\r\n        //             let userData = await this.getUserName(newInfo[i].userId);\r\n        //             members.push(userData.username);\r\n        //         }\r\n        //         this.members = members;\r\n        //     }\r\n        // },\r\n        mounted() {\r\n            this.messagesBuffer = [];\r\n            this.listen();\r\n        },\r\n        beforeDestroy() {\r\n            this.socket.off('message', this.onMessageReceived);\r\n            this.listening = false;\r\n            eventBus.off(`channel-${this.channelId}-update`, this.onChannelUpdateRequested);\r\n        },\r\n    };\r\n</script>\r\n<style scoped lang=\"scss\">\r\n    .main-content {\r\n        max-height: calc(100vh - 64px - 48px - 100px)\r\n    }\r\n\r\n    .message-textarea {\r\n        height: 160px;\r\n        max-height: 160px;\r\n\r\n        textarea {\r\n            margin-top: 5px;\r\n        }\r\n    }\r\n\r\n    .screen {\r\n        margin-top: 64px;\r\n        margin-left: 300px;\r\n    }\r\n\r\n    .messages-list {\r\n        margin: 1em;\r\n        overflow-y: auto;\r\n        overflow-x: hidden;\r\n    }\r\n\r\n    .system-message {\r\n        color: gray;\r\n        font-style: italic;\r\n    }\r\n\r\n    .own-message {\r\n        background-color: #fffedd;\r\n    }\r\n</style>\r\n"]}]}